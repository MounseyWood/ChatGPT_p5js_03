<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Cloth Simulation â€“ Plane & Draped (Sphere or Cylinder)</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
  <style>
    body, html {
      margin: 0; padding: 0;
      background: #111; color: #fff;
      font-family: sans-serif;
      height: 100%;
    }
    #uiPanel {
      position: absolute; top: 0; left: 0;
      width: 280px; height: 100%;
      background: #222; color: #fff;
      padding: 20px; box-sizing: border-box;
      overflow-y: auto; 
      box-shadow: 2px 0 8px rgba(0,0,0,0.5);
    }
    #canvasContainer {
      position: absolute; top: 0; left: 280px;
      width: calc(100% - 280px); height: 100%;
      overflow: hidden;
    }
    h2 { margin-top: 0; }
    p, label { font-size: 14px; line-height: 1.4em; margin-bottom: 8px; }
    .parameter {
      margin-bottom: 12px; padding-bottom: 8px;
      border-bottom: 1px solid #333;
    }
    .paramHeader { margin-bottom: 4px; font-weight: bold; }
    .paramRadio { display: flex; gap: 8px; margin-bottom: 4px; }
    .paramRadio input[type="radio"] { accent-color: #1e90ff; }
    input[type="range"] { accent-color: #1e90ff; }
    .paramContainer { display: none; margin-top: 4px; }
    .paramDesc { font-size: 12px; color: #aaa; margin-top: 4px; }
    .bottomButtons {
      position: sticky; bottom: 20px; width: 100%;
    }
    button {
      width: 100%; padding: 8px 12px; background: #555; color: #fff;
      border: none; cursor: pointer; margin-bottom: 10px;
    }
    button:hover { background: #666; }
  </style>
</head>
<body>
<div id="uiPanel">
  <h2>3D Cloth Simulation</h2>
  <p>
    Two main simulation modes: <strong>Plane</strong> or <strong>Draped</strong>.<br>
    In Draped mode, choose <strong>Sphere</strong> or <strong>Cylinder</strong>.
  </p>

  <div class="parameter">
    <div class="paramHeader">Simulation Mode:</div>
    <div id="simModeRadio"></div>
    <div class="paramDesc">
      <strong>Plane</strong>: pinned cloth in free space.<br>
      <strong>Draped</strong>: cloth drapes over a form.
    </div>
  </div>

  <div class="parameter" id="formModeParam">
    <div class="paramHeader">Form Mode:</div>
    <div id="formModeRadio"></div>
    <div class="paramDesc">
      Choose <strong>Sphere</strong> or <strong>Cylinder</strong>.
    </div>
  </div>

  <div class="parameter">
    <div class="paramHeader">Interaction Mode:</div>
    <div id="interactionRadioGroup"></div>
    <div class="paramDesc">
      "Rotate" = move camera; "Drag" = pick cloth points.
    </div>
  </div>

  <div class="parameter">
    <div class="paramHeader">Pinning Mode:</div>
    <div id="pinningRadio"></div>
    <div class="paramDesc">Only relevant in Plane mode.</div>
  </div>

  <div class="parameter">
    <div class="paramHeader">Damping: <span id="dampingVal"></span></div>
    <div class="paramRadio" id="dampingRadioGroup"></div>
    <div id="dampingContainer" class="paramContainer">
      <div id="dampingSlider"></div>
      <div class="paramDesc">Controls energy loss (Off = 1.0).</div>
    </div>
  </div>

  <div class="parameter">
    <div class="paramHeader">Iterations: <span id="iterationsVal"></span></div>
    <div class="paramRadio" id="iterationsRadioGroup"></div>
    <div id="iterationsContainer" class="paramContainer">
      <div id="iterationsSlider"></div>
      <div class="paramDesc">Constraint relaxations per frame (Off = 1).</div>
    </div>
  </div>

  <div class="parameter">
    <div class="paramHeader">Weight: <span id="weightVal"></span></div>
    <div class="paramRadio" id="weightRadioGroup"></div>
    <div id="weightContainer" class="paramContainer">
      <div id="weightSlider"></div>
      <div class="paramDesc">Downward pull (Off = 1.0).</div>
    </div>
  </div>

  <div class="parameter">
    <div class="paramHeader">Gravity: <span id="gravityVal"></span></div>
    <div class="paramRadio" id="gravityRadioGroup"></div>
    <div id="gravityContainer" class="paramContainer">
      <div id="gravitySlider"></div>
      <div class="paramDesc">Downward acceleration (Off = 0).</div>
    </div>
  </div>

  <div class="bottomButtons">
    <button id="playPauseBtn">Pause Simulation</button>
    <button id="resetOrientationBtn">Reset Orientation</button>
    <button id="resetBtn">Reset Cloth</button>
  </div>
</div>

<div id="canvasContainer"></div>

<script>
/* CLOTH SETTINGS */
let cols=20, rows=20, spacing=20;
let clothPoints=[], clothConstraints=[];
let grid=[], horizontal=[], vertical=[], centers=[];

/* SPHERE for Draped mode */
let sphereCenter={x:0,y:0,z:0};
let sphereRadius=100;

/* CYLINDER for Draped mode
   floor at y=150, cylinder bottom=150, top=450, radius=100, height=300. */
let floorY=150;
let cylRadius=100;
let cylHeight=300;
let cylinderBottomY=floorY;        // 150
let cylinderTopY=cylinderBottomY+cylHeight; // 450

/* SIMULATION PARAMETERS (default) */
let damping=0.98, iterations=5, weight=1.0, gravity=0.4;
let windX=0.2, windY=0, windZ=0.1, windBuffer=1.0;

/* BASELINE (Off) values */
const BASE_DAMPING=1.0, BASE_ITERATIONS=1, BASE_WEIGHT=1.0, BASE_GRAVITY=0.0;
let dampingOn=false, iterationsOn=false, weightOn=false, gravityOn=false, shadingOn=false;

/* MODES */
let pinningMode="top"; // Only for Plane
let interactionMode="rotate"; // "rotate" or "drag"
let simulationMode="plane";   // "plane" or "draped"
let formMode="sphere";        // "sphere" or "cylinder"

/* CLOTH SHIFT */
let clothShiftX=-40;

/* FLAGS */
let doResetOrientation=false, simulationRunning=true;

/* 3D Drag */
let dragPointIndex=null, dragPlaneZ=0;

function setup(){
  createCanvas(windowWidth-280,windowHeight,WEBGL).parent("canvasContainer");
  createUI();
  setupCloth();
}

function createUI(){
  // Reset & Orientation
  select("#resetBtn").mousePressed(setupCloth);
  select("#resetOrientationBtn").mousePressed(()=>{doResetOrientation=true;});
  const playPauseBtn=select("#playPauseBtn");
  playPauseBtn.mousePressed(()=>{
    simulationRunning=!simulationRunning;
    playPauseBtn.html(simulationRunning?"Pause Simulation":"Play Simulation");
  });

  // Simulation Mode
  let simRadio=createRadio();
  simRadio.option("plane","Plane");
  simRadio.option("draped","Draped");
  simRadio.selected("plane");
  simRadio.parent("simModeRadio");
  simRadio.changed(()=>{
    simulationMode=simRadio.value();
    setupCloth();
  });

  // Form Mode
  let formRadio=createRadio();
  formRadio.option("sphere","Sphere");
  formRadio.option("cylinder","Cylinder");
  formRadio.selected("sphere");
  formRadio.parent("formModeRadio");
  formRadio.changed(()=>{
    formMode=formRadio.value();
    if(simulationMode==="draped") setupCloth();
  });

  // Interaction
  let interRadio=createRadio();
  interRadio.option("rotate","Rotate");
  interRadio.option("drag","Drag");
  interRadio.selected("rotate");
  interRadio.parent("interactionRadioGroup");
  interRadio.changed(()=>{
    interactionMode=interRadio.value();
  });

  // Pinning Mode
  let pinRadio=createRadio();
  pinRadio.option("top","Top Pinned");
  pinRadio.option("corners","Corner Pinned");
  pinRadio.selected("top");
  pinRadio.parent("pinningRadio");
  pinRadio.changed(()=>{
    pinningMode=pinRadio.value();
    if(simulationMode==="plane") setupCloth();
  });

  // Minimal param toggles
  attachRadio("dampingRadioGroup",(on)=>{dampingOn=on;},"dampingContainer");
  attachRadio("iterationsRadioGroup",(on)=>{iterationsOn=on;},"iterationsContainer");
  attachRadio("weightRadioGroup",(on)=>{weightOn=on;},"weightContainer");
  attachRadio("gravityRadioGroup",(on)=>{gravityOn=on;},"gravityContainer");

  function attachRadio(parentId,callback,containerId){
    let r=createRadio();
    r.option("off","Off");
    r.option("on","On");
    r.parent(parentId);
    r.selected("off");
    r.changed(()=>{
      let val=r.value();
      let on=(val==="on");
      callback(on);
      if(containerId){
        if(on) select("#"+containerId).style("display","block");
        else select("#"+containerId).style("display","none");
      }
    });
  }

  // Sliders
  function makeSlider(divId,cb,minv,maxv,val,step){
    let s=createSlider(minv,maxv,val,step);
    s.parent(divId);
    s.input(()=>cb(s.value()));
    cb(s.value());
  }
  makeSlider("dampingSlider",(v)=>{damping=v;select("#dampingVal").html(nf(v,1,2));},0.9,1.0,0.98,0.01);
  makeSlider("iterationsSlider",(v)=>{iterations=v;select("#iterationsVal").html(v);},1,10,5,1);
  makeSlider("weightSlider",(v)=>{weight=v;select("#weightVal").html(nf(v,1,2));},0.5,2.0,1.0,0.1);
  makeSlider("gravitySlider",(v)=>{gravity=v;select("#gravityVal").html(nf(v,1,2));},0,1,0.4,0.01);
}

function setupCloth(){
  clothPoints=[];
  clothConstraints=[];
  grid=[];
  horizontal=[];
  vertical=[];
  centers=[];

  let clothWidth=(cols-1)*spacing;
  let clothHeight=(rows-1)*spacing;

  if(simulationMode==="plane"){
    let startX=-clothWidth/2+clothShiftX;
    let startY=-clothHeight/2;
    createClothPoints_Plane(startX,startY,0);
  }else{
    if(formMode==="sphere"){
      sphereCenter={x:0,y:0,z:0};
      sphereRadius=100;
      let startY=-sphereRadius; // -100
      createClothPoints_Draped(-clothWidth/2,startY,-clothHeight/2);
      let midRow=Math.floor(rows/2), midCol=Math.floor(cols/2);
      let centerIdx=grid[midRow][midCol];
      clothPoints[centerIdx].pinned=true;
      clothPoints[centerIdx].x=sphereCenter.x;
      clothPoints[centerIdx].y=sphereCenter.y-sphereRadius; // -100
      clothPoints[centerIdx].z=sphereCenter.z;
      clothPoints[centerIdx].oldx=sphereCenter.x;
      clothPoints[centerIdx].oldy=sphereCenter.y-sphereRadius;
      clothPoints[centerIdx].oldz=sphereCenter.z;
    }else if(formMode==="cylinder"){
      // Cylinder bottom on the floor (y=150), top=150+300=450
      cylinderBottomY=floorY; // 150
      cylHeight=300;
      cylinderTopY=cylinderBottomY+cylHeight; // 450
      let startY=cylinderTopY; // 450
      createClothPoints_Draped(-clothWidth/2,startY,-clothHeight/2);
      let midRow=Math.floor(rows/2), midCol=Math.floor(cols/2);
      let centerIdx=grid[midRow][midCol];
      clothPoints[centerIdx].pinned=true;
      clothPoints[centerIdx].x=0;
      clothPoints[centerIdx].y=cylinderTopY; // 450
      clothPoints[centerIdx].z=0;
      clothPoints[centerIdx].oldx=0;
      clothPoints[centerIdx].oldy=cylinderTopY;
      clothPoints[centerIdx].oldz=0;
    }
  }
  createSubPointsAndConstraints();
}

function createClothPoints_Plane(startX,startY,startZ){
  for(let y=0;y<rows;y++){
    grid[y]=[];
    for(let x=0;x<cols;x++){
      let px=startX+x*spacing, py=startY+y*spacing, pz=startZ;
      let pinned=false;
      if(pinningMode==="top"){ pinned=(y===0); }
      else if(pinningMode==="corners"){
        pinned=((x===0 && y===0)||
                (x===cols-1 && y===0)||
                (x===0 && y===rows-1)||
                (x===cols-1 && y===rows-1));
      }
      clothPoints.push({x:px,y:py,z:pz,oldx:px,oldy:py,oldz:pz,pinned});
      grid[y][x]=clothPoints.length-1;
    }
  }
}

function createClothPoints_Draped(startX,fixedY,startZ){
  for(let rz=0;rz<rows;rz++){
    grid[rz]=[];
    for(let cx=0;cx<cols;cx++){
      let px=startX+cx*spacing;
      let py=fixedY;
      let pz=startZ+rz*spacing;
      clothPoints.push({x:px,y:py,z:pz,oldx:px,oldy:py,oldz:pz,pinned:false});
      grid[rz][cx]=clothPoints.length-1;
    }
  }
}

function createSubPointsAndConstraints(){
  horizontal=[];
  for(let y=0;y<rows;y++){
    horizontal[y]=[];
    for(let x=0;x<cols-1;x++){
      let iA=grid[y][x], iB=grid[y][x+1];
      let A=clothPoints[iA], B=clothPoints[iB];
      let mx=(A.x+B.x)*0.5, my=(A.y+B.y)*0.5, mz=(A.z+B.z)*0.5;
      clothPoints.push({x:mx,y:my,z:mz,oldx:mx,oldy:my,oldz:mz,pinned:false});
      horizontal[y][x]=clothPoints.length-1;
    }
  }
  vertical=[];
  for(let y=0;y<rows-1;y++){
    vertical[y]=[];
    for(let x=0;x<cols;x++){
      let iA=grid[y][x], iB=grid[y+1][x];
      let A=clothPoints[iA], B=clothPoints[iB];
      let mx=(A.x+B.x)*0.5, my=(A.y+B.y)*0.5, mz=(A.z+B.z)*0.5;
      clothPoints.push({x:mx,y:my,z:mz,oldx:mx,oldy:my,oldz:mz,pinned:false});
      vertical[y][x]=clothPoints.length-1;
    }
  }
  centers=[];
  for(let y=0;y<rows-1;y++){
    centers[y]=[];
    for(let x=0;x<cols-1;x++){
      let iA=grid[y][x], iB=grid[y][x+1], iC=grid[y+1][x], iD=grid[y+1][x+1];
      let A=clothPoints[iA], B=clothPoints[iB], C=clothPoints[iC], D=clothPoints[iD];
      let mx=(A.x+B.x+C.x+D.x)*0.25;
      let my=(A.y+B.y+C.y+D.y)*0.25;
      let mz=(A.z+B.z+C.z+D.z)*0.25;
      clothPoints.push({x:mx,y:my,z:mz,oldx:mx,oldy:my,oldz:mz,pinned:false});
      centers[y][x]=clothPoints.length-1;
    }
  }
  createConstraints();
}

/* Only declared once: clothConstraints is at top! */
function createConstraints(){
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      let idx=grid[y][x];
      if(x<cols-1) addConstraint(idx,grid[y][x+1],spacing);
      if(y<rows-1) addConstraint(idx,grid[y+1][x],spacing);
    }
  }
}

function addConstraint(i,j,len){
  let a=min(i,j), b=max(i,j);
  for(let c of clothConstraints){
    if(c.p1===a && c.p2===b) return;
  }
  clothConstraints.push({p1:a,p2:b,length:len});
}

function draw(){
  background(30);
  if(doResetOrientation){
    camera(0,600,600,0,300,0,0,1,0);
    doResetOrientation=false;
  }
  if(interactionMode==="rotate") orbitControl();
  if(simulationRunning) updateCloth();

  if(simulationMode==="draped"){
    noStroke(); fill("#222");
    if(formMode==="sphere"){
      // Sphere radius=100, center=(0,0,0)
      push();
      translate(sphereCenter.x,sphereCenter.y,sphereCenter.z);
      sphere(sphereRadius);
      pop();
    }else{
      // Cylinder bottom=150, top=450 => midpoint=300
      push();
      translate(0,(cylinderBottomY+cylinderTopY)/2,0);
      cylinder(cylRadius,cylHeight);
      pop();
    }
    // invisible floor at y=150
    push();
    translate(0,floorY,0);
    noFill();
    plane(1000,1000);
    pop();
  }

  stroke(255); strokeWeight(2);
  for(let c of clothConstraints){
    let p1=clothPoints[c.p1], p2=clothPoints[c.p2];
    line(p1.x,p1.y,p1.z,p2.x,p2.y,p2.z);
  }
  noStroke(); fill("#FF0000");
  for(let p of clothPoints){
    push();
    translate(p.x,p.y,p.z);
    sphere(2);
    pop();
  }
}

function updateCloth(){
  let freq=0.01;
  for(let p of clothPoints){
    if(!p.pinned){
      let vx=(p.x-p.oldx)*(dampingOn?damping:BASE_DAMPING);
      let vy=(p.y-p.oldy)*(dampingOn?damping:BASE_DAMPING);
      let vz=(p.z-p.oldz)*(dampingOn?damping:BASE_DAMPING);
      p.oldx=p.x; p.oldy=p.y; p.oldz=p.z;
      let sinVal=sin(frameCount*freq);
      let windXEff=0, windYEff=0, windZEff=0;
      if(windXOn) windXEff=windBuffer*windX*sinVal;
      if(windYOn) windYEff=windBuffer*windY*sinVal;
      if(windZOn) windZEff=windBuffer*windZ*sinVal;
      let effGrav=(gravityOn?gravity:BASE_GRAVITY);
      let effWeight=(weightOn?weight:BASE_WEIGHT);
      p.x+=vx+windXEff;
      p.y+=vy+effGrav*effWeight+windYEff;
      p.z+=vz+windZEff;
    }
  }

  let effIter=(iterationsOn?iterations:BASE_ITERATIONS);
  for(let i=0;i<effIter;i++){
    for(let c of clothConstraints){
      let p1=clothPoints[c.p1], p2=clothPoints[c.p2];
      let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
      let distVal=sqrt(dx*dx+dy*dy+dz*dz);
      let diff=(distVal-c.length)/distVal;
      let offsetX=dx*0.5*diff, offsetY=dy*0.5*diff, offsetZ=dz*0.5*diff;
      if(!p1.pinned){p1.x+=offsetX; p1.y+=offsetY; p1.z+=offsetZ;}
      if(!p2.pinned){p2.x-=offsetX; p2.y-=offsetY; p2.z-=offsetZ;}
    }
  }
  doSelfCollision();
  if(simulationMode==="draped"){
    if(formMode==="sphere") doSphereCollision();
    else doCylinderCollision();
    doFloorCollision();
  }
}

function doSelfCollision(){
  let threshold=spacing*0.5;
  for(let i=0;i<clothPoints.length;i++){
    for(let j=i+1;j<clothPoints.length;j++){
      let p1=clothPoints[i], p2=clothPoints[j];
      let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
      let d=sqrt(dx*dx+dy*dy+dz*dz);
      if(d<threshold && d>0){
        let overlap=threshold-d;
        let angle=atan2(dy,dx);
        if(!p1.pinned && !p2.pinned){
          p1.x-=cos(angle)*overlap*0.5;
          p1.y-=sin(angle)*overlap*0.5;
          p2.x+=cos(angle)*overlap*0.5;
          p2.y+=sin(angle)*overlap*0.5;
        }else if(!p1.pinned && p2.pinned){
          p1.x-=cos(angle)*overlap;
          p1.y-=sin(angle)*overlap;
        }else if(p1.pinned && !p2.pinned){
          p2.x+=cos(angle)*overlap;
          p2.y+=sin(angle)*overlap;
        }
      }
    }
  }
}

function doSphereCollision(){
  const friction=0.5;
  for(let p of clothPoints){
    if(!p.pinned){
      let dx=p.x-sphereCenter.x, dy=p.y-sphereCenter.y, dz=p.z-sphereCenter.z;
      let distVal=sqrt(dx*dx+dy*dy+dz*dz);
      if(distVal<sphereRadius){
        let overlap=sphereRadius-distVal;
        let nx=dx/distVal, ny=dy/distVal, nz=dz/distVal;
        p.x+=nx*overlap; p.y+=ny*overlap; p.z+=nz*overlap;
        p.oldx=p.x-friction*(p.x-p.oldx);
        p.oldy=p.y-friction*(p.y-p.oldy);
        p.oldz=p.z-friction*(p.z-p.oldz);
      }
    }
  }
}

function doCylinderCollision(){
  const friction=0.5;
  for(let p of clothPoints){
    if(!p.pinned){
      // cylinder from y=150 to y=450
      if(p.y>=cylinderBottomY && p.y<=cylinderTopY){
        let r=sqrt(p.x*p.x + p.z*p.z);
        if(r<cylRadius){
          let overlap=cylRadius-r;
          let nx=p.x/r, nz=p.z/r;
          p.x+=nx*overlap; p.z+=nz*overlap;
          p.oldx=p.x-friction*(p.x-p.oldx);
          p.oldz=p.z-friction*(p.z-p.oldz);
        }
      }
    }
  }
}

function doFloorCollision(){
  // floor at y=150 => if p.y<150, clamp
  const friction=0.5;
  for(let p of clothPoints){
    if(!p.pinned && p.y<floorY){
      p.y=floorY;
      p.oldy=p.y-friction*(p.y-p.oldy);
    }
  }
}

/* 3D Dragging */
function mousePressed(){
  if(interactionMode==="drag"){
    let closest=null,closestDist=10;
    for(let i=0;i<clothPoints.length;i++){
      let p=clothPoints[i];
      let sx=modelX(p.x,p.y,p.z), sy=modelY(p.x,p.y,p.z);
      let d=dist(mouseX,mouseY,sx,sy);
      if(d<closestDist){closestDist=d;closest=i;}
    }
    if(closest!==null){
      dragPointIndex=closest;
      dragPlaneZ=clothPoints[closest].z;
    }
  }
}

function mouseDragged(){
  if(interactionMode==="drag" && dragPointIndex!==null){
    let newPos=unproject(mouseX,mouseY,dragPlaneZ);
    let p=clothPoints[dragPointIndex];
    p.x=newPos.x; p.y=newPos.y;
    p.oldx=newPos.x; p.oldy=newPos.y;
  }
}

function mouseReleased(){dragPointIndex=null;}

function unproject(mx,my,fixedZ){
  let d=(height/2)/tan(PI*30/180);
  let nx=mx-width/2, ny=my-height/2;
  let factor=(d+fixedZ)/d;
  return createVector(nx*factor, ny*factor, fixedZ);
}

function windowResized(){
  resizeCanvas(windowWidth-280,windowHeight);
}
</script>
</body>
</html>
